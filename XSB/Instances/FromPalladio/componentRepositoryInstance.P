% BEGIN IMPORTS
:- import  return/1
           from palladio.
:- import  returnType/2,
           providedInterface/2,
           providedRoles/2,
           basicComponent/1,
           dataType/2,
           parameters/2,
           signatures/2,
           requiredInterface/2,
           requiredRoles/2
           from fromPalladio.
:- import  member/2
           from lists.
% END IMPORTS

justify_pred(hasParameter(_,_)).
justify_pred(returnParameter(_,_)).
justify_pred(provides(_,_)).
justify_pred(requires(_,_)).



hasService(Interface, Service) :-
        signatures(Interface,Services),
        member(Service, Services).

hasParameter(Service,parm(Service,ParameterName)) :-
        % operationSignature(Service),
        parameters(Service, Parameters),
        member(ParameterName, Parameters).

returnParameter(Service,return(Service)) :-
        % operationSignature(Service),
        returnType(Service,_Type).

% TODO: this just cannot work with the current palladio fact export: if there are two different signatures with a common parameter name X,
% *two* facts dataType(X,Type) are generated. Luckily, typeOf/2 isn't currently uses anywhere in the access analysis.
typeOf(parm(Service,ParameterName),Type) :-
        hasParameter(Service, parm(Service,ParameterName)), % make this work as a generator
        once(dataType(ParameterName,Type)).                 % for the case that there are  two different signatures with a common parameter name X, pick the first only


typeOf(return(Service),Type) :-
        returnType(Service,Type).

provides(Component, Interface) :-
        basicComponent(Component),
        providedRoles(Component,Roles), member(Role,Roles),
        providedInterface(Role,Interface).

requires(Component, Interface) :-
        basicComponent(Component),
        requiredRoles(Component,Roles), member(Role,Roles),
        requiredInterface(Role,Interface).
